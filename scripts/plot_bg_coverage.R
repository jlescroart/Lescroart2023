#!/usr/bin/env Rscript
# or maybe /apps/conda/jonasl/envs/fastq2bam/bin/Rscript

# Script to plot coverage of bam file generated by deepTools' bamCoverage function
# Jonas Lescroart
# 20 November 2020

# USAGE
# plot_bg_coverage.R {input, full path} {chromosome tag} {read length, integer} {output, full path}
# Example use: $ Rscript --vanilla plot_bg_coverage.R /media/sf/cat.bg NC 125 /media/sf/cat.pdf
#
# Chromosome tag is the two letters of the reference assembly that indicate the chromosomes rather than the unlocated contigs.
# For felCat9, that is 'NC', for mLynCan4.pri.v2 that is 'CM'. It is needed to omit the small contigs.


# load libraries
library(ggplot2)
library(scales)
library(stringr)

# load functions

# Multiple plot function
# From http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_%28ggplot2%29/
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# input
args = commandArgs(trailingOnly=TRUE)

input <- args[1]
file.bg <- tail(str_split(args[1], "/")[[1]], n = 1)
tag <- args[2]
readlength <- as.integer(args[3])
output <- args[4]
file.pdf <- tail(str_split(args[4], "/")[[1]], n = 1)

# load data
deeptools <- read.table(
  file = input,
  header = F, 
  sep = '\t', 
  col.names = c('genbank_seq', 'start', 'end', 'reads'))

# coverage calculation from number of reads per window
windowsize = deeptools["end"][1,] - deeptools["start"][1,] 
deeptools$position_Mb <- deeptools$start / 1000000
deeptools$coverage <- (deeptools$reads * readlength) / windowsize

# list of chromosome IDs
chromosomes <- subset(deeptools, regexpr(tag, deeptools$genbank_seq) > 0)
chromosomes <- subset(chromosomes, !regexpr('Un_scaffold', chromosomes$genbank_seq) > 0)
chromosomes <- droplevels(unique(chromosomes$genbank_seq))

# empty plot list
plots <- vector("list", length(chromosomes)+1)

# plot coverage over whole genome
deeptools$position_Gb <- (1:length(deeptools$position_Mb))/10000
stats <- summary(deeptools$coverage)

coverage.plot <- ggplot(
  data = deeptools,
  aes(x = position_Gb, y = coverage)) + 
  scale_y_continuous(breaks = c(0,10, 20, 30, 40, 50, 60), limits = c(0, 60)) + 
  geom_point(alpha = 0.1) +
  geom_hline(yintercept = stats[[4]]) +
  labs(y = "Coverage", x = "Chromosome position (Gb)") +
  ggtitle(paste(file.bg, ", whole genome")) +
  scale_x_continuous(breaks = c(0, 0.5, 1, 1.5, 2, 2.5), limits = c(0, 2.5)) +
  annotate("rect", xmin = 1.75, xmax = 2.50, ymin = 55, ymax = 60, alpha = .2) +
  annotate("text", x = 2.12, y = c(57.5), 
           label = 
             paste("deepTools mean is ", as.character(round(stats[[4]], digits = 2)), "X"))
plots[[1]] <- coverage.plot

# plot coverage per chromosome
for (i in 1:length(chromosomes)) {
  chromosome <- subset(deeptools, regexpr(chromosomes[i], deeptools$genbank_seq) > 0)
  stats_chr <- summary(chromosome$coverage)
  # plot
  coverage.plot <- ggplot(
    data = chromosome,
    aes(x = position_Mb, y = coverage)) + 
    scale_y_continuous(breaks = c(0,10, 20, 30, 40, 50, 60), limits = c(0, 60)) + 
    geom_point(alpha = 0.1) +
    geom_hline(yintercept = stats_chr[[4]]) +
    labs(y = "Coverage", x = "Chromosome position (Mb)") +
    ggtitle(paste(file.bg, ", chromosome", unique(chromosome$genbank_seq))) +
    scale_x_continuous(breaks = c(0, 50, 100, 150, 200, 250), limits = c(0, 250)) +
    annotate("rect", xmin = 175, xmax = 250, ymin = 55, ymax = 60, alpha = .2) +
    annotate("text", x = 212, y = c(57.5), 
             label = 
               paste("deepTools mean is ", as.character(round(stats_chr[[4]], digits = 2)), "X"))
  plots[[i+1]] <- coverage.plot
}

# save plot
ggsave(
  filename = file.pdf, 
  plot = multiplot(plotlist = plots, cols=2), 
  device = "pdf",
  path = dirname(output),
  width = 8.3, height = 11.7,
  scale = 2)


# Part to swap the genbank or refseq IDs for the actual chromosome names but hard to automate for multiple reference genomes.

#realchroms<-list("A1", "A2", "A3", "B1", "B2", "B3", "B4", 
#                 "C1", "C2", "D1", "D2", "D3", "D4", "E1", "E2", "E3", 
#                 "F1", "F2", "X", "Y", "mtDNA")
#deeptools$molecule <- deeptools$genbank_seq
#for (i in 1:length(chromosomes)){
#  deeptools$molecule[deeptools$molecule==chromosomes[i]]<-realchroms[i]
#}
